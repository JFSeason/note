(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{352:function(t,s,e){t.exports=e.p+"assets/img/socket01.b19c56f5.png"},353:function(t,s,e){t.exports=e.p+"assets/img/socket02.a0486c95.png"},354:function(t,s,e){t.exports=e.p+"assets/img/socket03.edb433be.png"},363:function(t,s,e){"use strict";e.r(s);var n=e(42),l=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"netty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[t._v("#")]),t._v(" Netty")]),t._v(" "),n("p",[n("img",{attrs:{src:e(352),alt:"result"}}),t._v("\n一个程序可以分为三部分：输入，输出，中间是处理")]),t._v(" "),n("ul",[n("li",[t._v("httpserver启动的时候会监听一个端口，客户端就可以使用服务器端的IP、域名，然后将一个socket连接上，建立了连接后，就可以通信了，相互之间就可以发消息，也有了InputStream和OutputStream读写流的概念，最后通信完了，就把它关掉。")]),t._v(" "),n("li",[t._v("IP用来标识一个机器，在局域网内分配一个IP地址，我们就可以根据这个IP地址来识别它。在广域网上，就是一个真实的IP，然后这个IP就可以作为一个物理地址访问它\n端口是用来区分我通信的时候要和我通信的那个进程到底是这台计算机的哪个，或者说 我访问的是哪个服务。")]),t._v(" "),n("li",[t._v("IP地址一般对应的计算机，端口对应这个计算机里能够提供某种服务的进程。IP相当于邮编，端口相当于门牌号")]),t._v(" "),n("li",[t._v("服务器通信过程过程分析：\n计算机内部所有的处理总结起来分为两大类\n（1）CPU的计算处理/业务处理\n（2）IO操作与等待的处理/网络、磁盘、数据库")])]),t._v(" "),n("p",[n("img",{attrs:{src:e(353),alt:"result"}})]),t._v(" "),n("ul",[n("li",[t._v("服务器端和客户端通过网络调用读数据或者写数据，同事接收到数据以后服务器的CPU要做计算，一般我们的应用会操作磁盘，读磁盘上的文件，或者去访问数据库，走另外一个网络的IO。")]),t._v(" "),n("li",[t._v("上图为读本地文件的例子，是一个本地磁盘IO的调用（用户请求访问本地的文件，服务器把本地文件读出来，然后返回给用户，整个资源设计图如上图）")]),t._v(" "),n("li",[t._v("R表示读，W表示写，C表示close")]),t._v(" "),n("li",[t._v("网络读到请求是干嘛的，然后从磁盘（disk syscalls）里去读文件，读完之后写到用户的socket里去发给用户，再读文件再发给用户，一直把这个文件处理完，最后整个close掉，整个过程中CPU的使用特别少。大部分CPU资源都处理等待状态，被浪费了。怎么优化呢")])]),t._v(" "),n("p",[n("img",{attrs:{src:e(354),alt:"result"}}),t._v("\n优化类似于上图，把不受干扰，并行的部分进行细分，然后就可以让整个处理变得更高效，类似于GC的并发收集。简单来说就是线程不等了，IO操作完了通知我，然后我线程再去干活，具体的处理方法后面进行说明。")])])}),[],!1,null,null,null);s.default=l.exports}}]);